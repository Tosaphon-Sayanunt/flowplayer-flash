/* * This file is part of Flowplayer, http://flowplayer.org * * By: Anssi Piirainen, <api@iki.fi> * * Copyright (c) 2008-2011 Flowplayer Oy * * Released under the MIT License: * http://www.opensource.org/licenses/mit-license.php */package org.flowplayer.volume.ui {	import flash.system.System;		    import flash.display.DisplayObject;    import flash.events.Event;    import flash.events.MouseEvent;    import flash.filters.GlowFilter;    import org.flowplayer.config.ConfigParser;    import org.flowplayer.controller.ResourceLoader;    import org.flowplayer.flow_internal;    import org.flowplayer.volume.*;    import org.flowplayer.model.DisplayPluginModel;    import org.flowplayer.model.Plugin;       import org.flowplayer.model.PluginModel;    import org.flowplayer.model.PlayerEvent;    import org.flowplayer.ui.containers.WidgetContainer;    import org.flowplayer.ui.containers.WidgetContainerEvent;    import org.flowplayer.ui.dock.Dock;    import org.flowplayer.ui.dock.DockConfig;    import org.flowplayer.util.PropertyBinder;    import org.flowplayer.view.AbstractSprite;    import org.flowplayer.view.Flowplayer;    import org.flowplayer.view.Styleable;        import flash.external.*;    import flash.utils.*;    use namespace flow_internal;    public class Volume extends AbstractSprite implements Plugin, Styleable {                	private var _config:VolumeConfig;        private var _dock:Dock;        private var _player:Flowplayer;        private var _name:String;        private var _volumeButtonController:VolumeButtonController;        private var _volumeButtonContainer:WidgetContainer;        private var _model:PluginModel;        public  var mOverTimeout:uint;        private var _volumeObj:VolumeItem;                public  var isMouseOver:Boolean;               private function get model():DisplayPluginModel {            return DisplayPluginModel(_player.pluginRegistry.getPlugin(_name));        }        public function onConfig(model:PluginModel):void {            _model = model;            _name = model.name;            _config = new PropertyBinder(new VolumeConfig()).copyProperties(model.config) as VolumeConfig;                    }        public function onLoad(player:Flowplayer):void {            _player = player;                        createDock();            			var volumeItemConfig:VolumeItemConfig = new VolumeItemConfig();			volumeItemConfig.setColor("#000000");			volumeItemConfig.setOverColor("#000000");			createItem(volumeItemConfig);            updateModelHeight();            _model.dispatchOnLoad();            _player.onFullscreen(function(event:PlayerEvent):void {                adjustDockPosition();            });            _player.onFullscreenExit(function(event:PlayerEvent):void {                adjustDockPosition();            });            createVolumeButton(player);        }        override protected function onResize():void {            _dock.setSize(width, height);            updateModelHeight();        }        private function updateModelHeight():void {            updateModelProp("height", _dock.height);        }        internal function updateModelProp(prop:String, value:Object):void {            var myModel:DisplayPluginModel = model;            myModel[prop] = value;            _player.pluginRegistry.updateDisplayProperties(myModel);        }        private function get horizontalPosConfigured():Boolean {            var confObj:Object = _player.config.getObject("plugins")[_name];            return confObj && (confObj.hasOwnProperty("left") || confObj.hasOwnProperty("right"));        }        private function get verticalPosConfigured():Boolean {            var confObj:Object = _player.config.getObject("plugins")[_name];            return confObj && (confObj.hasOwnProperty("top") || confObj.hasOwnProperty("bottom"));        }        public function getDefaultConfig():Object {            return { width: 150, height: 100 };        }        private function createVolumeButton(player:Flowplayer):void {            if (! _config.button.dockedOrControls) return;            if (_config.button.controls) {                log.debug("onLoad() adding menu button to controls");                //#584 make the controls plugin name configurable.                var controlbar:* = player.pluginRegistry.plugins[_config.controlsPlugin];                // TODO: Container events should follow the same pattern as player, clip and plugin events                controlbar.pluginObject.addEventListener(WidgetContainerEvent.CONTAINER_READY, addControlsVolumeButton);            }        }        /**         * Get the menu button controller         */        public function get volumeButtonController():VolumeButtonController        {            return _volumeButtonController;        }        private function addControlsVolumeButton(event:WidgetContainerEvent):void {            log.debug("addControlsMenuButton()");            _volumeButtonContainer = event.container;            _volumeButtonController = new VolumeButtonController(_player,  model);            _volumeButtonContainer.addWidget(_volumeButtonController, "time", false);            if (this.stage) {                adjustDockPosition();            } else {                // the position will be adjuster every time the menu becomes visible                //#7 adjust the dock once the stage is available                this.addEventListener(Event.ADDED_TO_STAGE, adjustDockOnStage);            }        }        private function adjustDockPosition():void {            if (horizontalPosConfigured && verticalPosConfigured) return;            var myModel:DisplayPluginModel = model;			var controlbar:* = _player.pluginRegistry.plugins[_config.controlsPlugin];			            if (! horizontalPosConfigured) {                myModel.left = _volumeButtonController.view.x + controlbar.pluginObject.x;                log.debug("adjustDockPosition(), menuButton.x = " + _volumeButtonController.view.x);                log.debug("adjustDockPosition(), horizontal menu position adjusted to " + myModel.position);            }            if (! verticalPosConfigured) {                if ( stage) {                    myModel.bottom = (stage.stageHeight - DisplayObject(_volumeButtonContainer).y) + 90;                } else {                   //#7 adjust the dock once the stage is available                   this.addEventListener(Event.ADDED_TO_STAGE, adjustDockOnStage);                   return;                }                log.debug("adjustDockPosition(), menuButtonContainer.y = " + _volumeButtonContainer["y"]);                log.debug("adjustDockPosition(), vertical menu position adjusted to " + myModel.position);            }            _player.animationEngine.animate(this, myModel, 0);        }        /**         * #7 adjust the dock once the stage is available once only.         * @param event         */        private function adjustDockOnStage(event:Event):void        {            adjustDockPosition();            this.removeEventListener(Event.ADDED_TO_STAGE, adjustDockOnStage);        }        private function createDock():void {            log.debug("createDock()");            var dockConfig:DockConfig = new DockConfig();            dockConfig.model = DisplayPluginModel(model.clone());                        //updateModelProp("display", "none");            //updateModelProp("alpha", 0);            //this.alpha = 0;			_player.animationEngine.fadeOut(this);            _dock = new Dock(_player, dockConfig);            addChild(_dock);            // GlowFilter(color:uint = 0xFF0000, alpha:Number = 1.0, blurX:Number = 6.0, blurY:Number = 6.0, strength:Number = 2, quality:int = 1, inner:Boolean = false, knockout:Boolean = false)            this.filters = [new GlowFilter(0x000000, 0.8, 5, 5, 1, 3)];                        this.addEventListener(MouseEvent.MOUSE_OVER, dockMouseOver);			this.addEventListener(MouseEvent.MOUSE_OUT, dockMouseOut);        }                private function dockMouseOver(event:MouseEvent):void{			clearTimeout(mOverTimeout);			_player.animationEngine.cancel(this);			this.updateModelProp("display", "block");			_player.animationEngine.fadeTo(this, 0.7);			ExternalInterface.call("thaitv.setControlAutohide", false);		}		 		private function dockMouseOut(event:MouseEvent):void{                        	//setTimeoutDock();           	if(mOverTimeout != 0) {        			clearTimeout(mOverTimeout);        		}           hideDock();		}        private function createItem(itemConfig:VolumeItemConfig):void {            itemConfig.width = model.widthPx;            _volumeObj = new VolumeItem(_player, itemConfig, _player.animationEngine);            itemConfig.view = _volumeObj;                        _volumeObj.height = itemConfig.height;            _dock.addIcon(_volumeObj);        }        public function onBeforeCss(styleProps:Object = null):void {        }        public function css(styleProps:Object = null):Object {            return null;        }        public function onBeforeAnimate(styleProps:Object):void {        }        public function animate(styleProps:Object):Object {            return null;        }                public function setTimeoutDock():void {        		if(mOverTimeout != 0) {        			clearTimeout(mOverTimeout);
        		}        		mOverTimeout = setTimeout(hideDock, 800); 
        }                private function hideDock():void {        		//ExternalInterface.call("console.log", "hideDock");        		_player.animationEngine.fadeOut(this,300);            ExternalInterface.call("thaitv.setControlAutohide", true);            //_volumeButtonController.getBitrateButton().isOpenMenu = false;            this.isMouseOver = false;
        }                public function clearTimer():void {        	    if(mOverTimeout != 0) {        			clearTimeout(mOverTimeout);        		}        		
        }                public function updateVolume(num:Number):void {        		_volumeObj.externalUpdateVolume(num);        		
        }    }}