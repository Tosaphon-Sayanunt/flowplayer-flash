/* * This file is part of Flowplayer, http://flowplayer.org * * By: Anssi Piirainen, <support@flowplayer.org> * Copyright (c) 2008-2011 Flowplayer Oy * * Released under the MIT License: * http://www.opensource.org/licenses/mit-license.php */package org.flowplayer.relatedvideo {    import flash.filters.GlowFilter;        import org.flowplayer.model.DisplayPluginModel;    import org.flowplayer.view.FlowStyleSheet;    import org.flowplayer.view.Flowplayer;    import org.flowplayer.view.StyleableSprite;        import flash.display.BlendMode;    import flash.display.DisplayObject;    import flash.display.Loader;    import flash.display.Sprite;        import flash.events.*;	import flash.text.Font;    import flash.text.AntiAliasType;    import flash.text.TextField;    import flash.text.TextFieldAutoSize;    import flash.external.ExternalInterface;    	import flash.net.URLRequest;    /**     * @author api     */    public class ContentView extends StyleableSprite {        private var _text:TextField;        private var _textMask:Sprite;        private var _htmlText:String;        private var _player:Flowplayer;                private var _imageContainer:Sprite;        private var _imageContainerMask:Sprite;                private var _gap:Number = 10;        private var _startImageArea:Number = 30;		private var _currentImageX:Number = _startImageArea;		private var _imageWidth:Number;		private var _imageHeight:Number;		private var _imageY:Number;		private var _loader:Loader;		private var _urlImageList:Object;		private var _imageObjList:Array;						//embed font        [Embed(source="./fonts/thaisansneue-bold.ttf", fontFamily="thaisansneueBold", mimeType="application/x-font-truetype",     embedAsCFF="false", unicodeRange="U+0020-007E,U+0E01-0E5B")]         public var thaisansneueBoldFont:Class;		        public function ContentView(player:Flowplayer) {            	            	super(null, player, player.createLoader());            _player = player;					Font.registerFont(thaisansneueBoldFont);						_imageContainer = new Sprite();			addChild(_imageContainer);						_imageContainerMask = new Sprite();        		addChild(_imageContainerMask);        		        		_imageContainer.mask = _imageContainerMask;        }                public function loadAllImages(urlImageList:Object, imageWidth:Number, imageHeight:Number, imageY:Number):void {        		        		_urlImageList = urlImageList;			_imageWidth = imageWidth;			_imageHeight = imageHeight;			_imageY = imageY;	        		        		_imageObjList = new Array();        		        		loadImage(_urlImageList[0], 0);        		        				}				private function loadImage(imgData:Object, imgIndex:Number):void {			_loader = new  Loader();			configureListeners(_loader.contentLoaderInfo, imgIndex);			if(imgData && imgData.imageUrl) {				_loader.load(new URLRequest(imgData.imageUrl));				_loader.addEventListener(MouseEvent.CLICK, function(event:MouseEvent):void {	            		ExternalInterface.call("window.thaitv.navigateUrl", imgData.videoUrl);	            });			}	
		}				private function configureListeners(dispatcher:IEventDispatcher, index:Number):void {            dispatcher.addEventListener(Event.COMPLETE, function(e:Event):void {             		completeHandler(e, index);            		loadImage(_urlImageList[++index], index);
            });            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);            dispatcher.addEventListener(Event.INIT, initHandler);            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);            dispatcher.addEventListener(Event.OPEN, openHandler);            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);            dispatcher.addEventListener(Event.UNLOAD, unLoadHandler);        }                private function completeHandler(event:Event, index:Number):void {			var ld:Loader = event.currentTarget.loader as Loader;			var imgObj:RelatedImageObject = new RelatedImageObject(ld,	_imageWidth, _imageHeight);            imgObj.x = _currentImageX;             imgObj.y = _imageY;                       imgObj.addEventListener(MouseEvent.MOUSE_OVER, function(e:Event):void {            		e.currentTarget.showBlueBorder();
            });            imgObj.addEventListener(MouseEvent.MOUSE_OUT, function(e:Event):void {            		e.currentTarget.hideBlueBorder();            });            //            if(index == 0) {//            		imgObj.showBlueBorder();
//            }            _imageObjList.push(imgObj);            _imageContainer.addChild(imgObj);            _currentImageX += (_gap + _imageWidth);        }        private function httpStatusHandler(event:HTTPStatusEvent):void {                    }        private function initHandler(event:Event):void {                    }        private function ioErrorHandler(event:IOErrorEvent):void {                    }        private function openHandler(event:Event):void {                    }        private function progressHandler(event:ProgressEvent):void {                    }        private function unLoadHandler(event:Event):void {                    }                public function drawImageContainerMask():void {        		var maskWidth:Number = _player.isFullscreen() ? width : 1000;        		_imageContainerMask.graphics.clear();            _imageContainerMask.graphics.beginFill(0x000000,1);            _imageContainerMask.graphics.drawRect(0, 0, maskWidth - 60, height);            _imageContainerMask.graphics.endFill();            _imageContainerMask.x = _startImageArea;            _imageContainerMask.y = 0;            _imageContainerMask.width = maskWidth - 60;            _imageContainerMask.height = height;		}        override protected function onSetStyle(style:FlowStyleSheet):void {            log.debug("onSetStyle");            createTextField(_text ? _text.htmlText : null);        }        override protected function onSetStyleObject(styleName:String, style:Object):void {            log.debug("onSetStyleObject");            createTextField(_text ? _text.htmlText : null);        }        public function set html(htmlText:String):void {            _htmlText = htmlText;            if (! _htmlText) {                _htmlText = "";            }            _text.htmlText = "<body>" + _htmlText + "</body>";            log.debug("set html to " + _text.htmlText);        }        public function get html():String {            return _htmlText;        }        private function createTextField(htmlText:String = null):void {            log.debug("creating text field for text " + htmlText);            if (_text) {                removeChild(_text);            }            _text = _player.createTextField();			_text.selectable = false;            _text.blendMode = BlendMode.LAYER;            _text.autoSize = TextFieldAutoSize.CENTER;            _text.wordWrap = true;            _text.multiline = true;            _text.antiAliasType = AntiAliasType.ADVANCED;            _text.condenseWhite = true;			_text.embedFonts = true;            log.info("style.textDecoration " + style.textDecoration);            if (style.textDecoration == "outline") {                log.debug("setting textDecoration")                var glow:GlowFilter = new GlowFilter(0, .80, 2, 4, 6);                var filters:Array = [glow];                _text.filters = filters;            }            addChild(_text);            if (style) {                _text.styleSheet = style.styleSheet;            }            if (htmlText) {                log.debug("setting html to " + htmlText);                html = htmlText;            }            _textMask = createMask();            addChild(_textMask);            _text.mask = _textMask;            arrangeText();        }        private function arrangeText():void {            if (! (_text && style)) return;            var padding:Array = style.padding;            log.debug("arranging text with padding " + padding + " height is " + height);            // only reset values if they change, otherwise there will be visual "blinking" of text/images            setTextProperty("y", padding[0]);            setTextProperty("x", padding[3]);            setTextProperty("height", height - padding[0] - padding[2]);            setTextProperty("width", width - padding[1] - padding[3]);        }        private function setTextProperty(prop:String, value:Number):void {            if (_text[prop] != value) {                log.debug("setting text property " + prop + " to value " + value);                _text[prop] = value;            }        }        override protected function onRedraw():void {              arrangeText();        }        override protected function onResize():void {            if (_textMask) {                _textMask.width = width;                _textMask.height = height;            }        }        override public function set alpha(value:Number):void {            super.alpha = value;            if (! _text) return;            _text.alpha = value;        }                public function getArrowPos():Number {        		return _imageY + (_imageContainer.height /2);
        }                public function moveImage(moveRange:Number):void {        	            		if(moveRange < 0) {    				if(_imageContainer.x + _imageContainer.width + moveRange < _imageContainerMask.width) {	        			_imageContainer.x = _imageContainerMask.width - _imageContainer.width;		        		} else {	        			_imageContainer.x  += moveRange;
	        		}		        	} else {	        		if(_imageContainer.x + moveRange > 0) {	        			_imageContainer.x = 0;
	        		} else {	        			_imageContainer.x  += moveRange;
	        		}
	        	}
        }                public function isShowArrow():Boolean {        		return (_imageContainerMask.width < _imageContainer.width);
        }    }}